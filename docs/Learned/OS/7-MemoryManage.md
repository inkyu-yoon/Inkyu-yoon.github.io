---
layout: post
title: "· 메모리 분할 시스템의 종류와 특징"
nav_order: 7
parent : 운영체제
grand_parent: 📚Learned
permalink: docs/Learned/OS/MemoryManage
---

# 메모리 분할 시스템의 종류와 특징
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---




## 메모리 관리의 복잡성

<br>

CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터 (MAR)를 사용한다.

MAR에 필요한 메모리 주소를 넣으면 데이터를 메모리에서 가져오거나 메모리에 데이터를 옮길 수 있다.

<br>

폰노이만 구조의 컴퓨터에서 모든 프로그램은 메모리에 올라와야 실행이 가능하다.

오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡하다.

<br>

> 프로그램을 메모리에서 실행하는 이유
>
> 속도가 빠른 메모리는 하드디스크와 비교했을 때, 용량 당 단가가 매우 비싸다.
>
> 따라서, 메모리는 하드디스크 만큼 큰 용량을 갖기에는 단가가 맞지 않아 저장장치로 사용하지 않고
>
> 대신, CPU 작업공간으로 사용하기에는 하드디스크보다 적합하여 사용한다.

<br>

## 메모리 관리자의 역할

<br>

1. 가져오기 작업 : 프로세스와 데이터를 메모리로 가져오는 작업이다.
2. 배치 작업 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다. 배치 작업 전, 메모리를 어떤 크기로 자르는지에 따라 메모리 관리의 복잡성이 달라진다.
3. 재배치 작업 : 새로운 프로세스를 가져오기 위해, 오래된 프로세스를 내보내는 작업이다.

<br>

## 메모리 주소

<br>

CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.

32bit CPU 내의 레지스터 크기는 전부 32bit, 논리 연산장치도 32bit를 처리할 수 있도록 설계되어 있고, 데이터를 전송하는 버스의 크기 (대역폭) 도 32bit이다.

또한, 비트수에 따라 표현할 수 있는 메모리 주소의 수도 달라진다.

<br>


<p align="center">

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219152224251.png" alt="image-20230219152224251" style="zoom:80%;" />

</p>

메모리는 운영체제 영역과 사용자 영역으로 나누어 관리된다. 운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에, 사용자가 침범하지 못하도록 분리하여 관리한다.

그리고, 사용자 영역이 시작되는 주소에 경계 레지스터가 있고 사용자 영역이 운영체제 영역으로 침범하는 것을 막는 역할을 한다.

<br>

### 절대 주소

<br>

절대 주소란, 실제 물리 주소를 가리키는 주소로 메모리 관리자 입장에서 바라본 주소이다.

컴퓨터에 꽂힌 램 메모리의 실제 주소를 말한다.

어떤 프로세스가 메모리 400번지에 올라왔다면, 이 프로세스의 절대 주소는 400번지이다.

<br>

### 상대 주소

<br>

상대 주소란, 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식이다. (상대 주소 = 절대 주소 - 경계 레지스터 주소)

어떤 프로세스가 메모리 400번지에 올라왔고, 경계 레지스터 주소가 360번지라면 이 프로세스의 상대 주소는 40번지이다.

상대 주소는, **논리 주소 공간**이라고도 부른다.

<br>

## 메모리 분할

<br>

<p align="center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219154221406.png" alt="image-20230219154221406" style="zoom: 80%;" />
</p>

### 가변 분할 방식

<br>

프로세스의 크기에 따라 메모리를 나누는 것

프로세스의 크기에 맞게 메모리가 분할 되므로, 메모리 영역이 각각 다르다.

한 프로세스가 연속된 공간에 배치되기 때문에 **연속 메모리 할당**이라고 한다.

한 프로세스를 연속된 공간에 배치할 수 있어 연속적으로 처리가 가능하다는 장점이 있지만,

여유 메모리 공간에 따라 메모리 통합 등의 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.

<p align="center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219154644917.png" alt="image-20230219154644917" style="zoom:67%;" />
</p>

가변 분할 방식은, 프로세스를 분할하지 않고 연속적으로 처리하려다 보니, 빈 공간이 있음에도 빈공간이 연속적으로 붙어있지 않아 대기중인 프로세스를 메모리에 배정하지 못하는 현상이 일어날 수 있다.

<p align="center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219154840893.png" alt="image-20230219154840893" style="zoom: 80%;" />
</p>

배정받지 못하는 빈 메모리 공간을 외부 단편화라고 한다.

위 그림에서 만약 대기중인 프로세스의 메모리가 19KB 라면 2개의 외부 단편화가 생긴다.

외부 단편화 문제를 해결하기 위해 메모리 배치 방식(작은 조각이 발생하지 않도록 프로세스를 배치)이나 조각 모음(작은 조각들을 모아 하나의 덩어리로 만듦)을 사용한다.

<br>

> 메모리 배치 방식
>
> 1. 최초 배치 : 첫번째로 발견한 공간에 프로세스를 배치
> 2. 최적 배치 : 메모리의 빈 공간 중, 프로세스의 메모리와 가장 비슷한 크기인 공간에 배치
> 3. 최악 배치 : 가장 크게 비어있는 공간에 배치
>
> 조각 모음
>
> 메모리 배치 방식을 사용해도, 낭비 공간을 완벽하게 없애는 것은 불가능하다.
> 서로 떨어져 있는 여러개의 빈 공간을 합치는 작업을 조각 모음이라고 하고, 조각 모음 실행 시 프로세스의 동작을 멈추고, 이동시키고 다시 시작해야 해서 시간이 걸릴 수 있다.

<br>

### 고정 분할 방식

<br>
프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것

한 프로세스가 분산되어 배치되기 때문에, 비연속 메모리 할당 이라고 한다.

분할하는 메모리 영역 크기가 고정되어 있어, 분할하는 메모리 영역보다 작은 프로세스가 영역에 들어오면 낭비되는 메모리가 발생한다.

<br>
가변 분할 방식에는 외부 단편화가 있었다면, 고정 분할 방식은 내부 단편화가 존재한다.

<p align="center">

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219183105431.png" alt="image-20230219183105431" style="zoom:80%;" />

</p>

위 그림 처럼 20KB로 고정 분할을 하면, 20KB 미만인 프로세스가 공간을 할당받으면 남는 메모리가 생기고, 이를 내부 단편화라고 한다.

외부 단편화를 해결하는 것 처럼 조각 모음을 할 순 없고, 동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화 한다.

얼마로 나눠야 하는지에 대한 정답은 없고, 신중하게 메모리의 크기를 결정해서 나누어야 한다.

<br>

### 버디 시스템

<br>

버디 시스템은 가변 분할 방식의 단점인 외부 단편화를 완화하는 방법이다.

메모리를 1/2씩 자르다가 프로세스에 맞는 크기가 되면 할당하는 방식이다.

<p align="center">

<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219185436275.png" alt="image-20230219185436275" style="zoom:80%;" />
</p>

총 메모리가 16칸이 있고, 메모리 칸이 3개가 필요한 프로세스 A가 들어온다고 할때,

1/2씩 나누다보면, 4칸짜리에 넣을 수 있기 때문에 메모리 공간이 4칸인 영역에 프로세스 A를 넣는다.

다른 프로세스도 위와 같은 방식으로 영역을 할당한다.

<p align="center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219185825047.png" alt="image-20230219185825047" style="zoom:80%;" />
</p>

위 상태에서, F가 나가면 7번과 8번을 가변 분할 방식의 조각모음 처럼 통합하여 2칸을 확보하고, I 프로세스에게 할당할 수 있다.

가변 분할 방식 보다 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여있어 통합하기 쉽고,

<p align="center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230219190532902.png" alt="image-20230219190532902" style="zoom:80%;" />
</p>

위 상황에서 A가 나간다고 가정했을 때,

버디 시스템은 A가 나가면 4칸을 할당해줄 수 있어 H가 바로 들어올 수 있지만

만약 가변 분할 시스템이었다면, A가 있던 영역은 3칸짜리였을 것이고, A가 나가도 4칸이 필요한 H는 메모리를 할당받지 못했을 것이다.